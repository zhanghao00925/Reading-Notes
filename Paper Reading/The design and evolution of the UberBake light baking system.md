# The design and evolution of the UberBake light baking system

UberBake是一款由动视公司开发的GI系统，它支持有限的照明变化以回应特定玩家的互动。我们不使用完全动态的解决方案，而是使用传统的静态光照烘培流水线，并扩展它，使我们能够在运行时以最小的性能和内存开销动态更新预先计算的光照。我们展示了如何有效地预先计算由于单个灯的启用和禁用以及门的开启和关闭而引起的照明变化。

# INTRODUCTION

渲染过程的难点之一是计算全局光照——不是直接来自光源，而是经过场景中其他表面的一些反射后到达每个点的光照成分。考虑到有限的时间预算，大多数现代游戏引擎都依赖于某种形式的预计算或烘焙。实时光线追踪不太可能取代当前基于烘烤的解决方案，甚至不太可能普遍使用，至少在下一代主机上(对于移动平台可能会更久)。然而，烘培照明的局限性是显著的。任何几何图形的改变都需要花费大量的离线更新，这通常会花费数小时，大大增加了艺术家的迭代时间。因为预先计算是在假定静态层次几何图形的情况下执行的，所以运行时的任何更改都不会对光照产生影响。例如，一个玩家可能会破坏一堵墙，而这堵墙应该会让光线充满建筑内部;然而，由于照明是预先计算与墙壁完整，没有可用的信息，关于如何在房间内的照明分布应改变时，它不再在那里。即使是像打开门这样简单的交互也可能会使关卡的灯光处于不一致的状态。

UberBake是在多次发行的过程中开发出来的，创新主要是由游戏玩法和关卡设计需求驱动的。我们工作的核心观点是，我们可以选择影响照明(启用/禁用灯和打开/关闭门)的用户交互的有限子集，并从一个完全动态的GI解决方案中获得许多好处。这使得1)有效地预先计算与每个交互相关的光照变化，2)实现一个运行时系统，平均来说，不会比我们之前的完全静态实现慢，并使用最小的额外内存，它与允许的交互数量线性扩展。

## 设计标准

**C.1 接近于零的运行时开销**

我们希望在各种各样的硬件上发行60帧/秒的游戏，从现代游戏pc到控制台和智能手机。

**C.2 没有附加的几何约束**

当我们实现我们的系统时，已经有了大量的内容。因为重做大部分内容是不可行的，所以系统必须在只需要少量级别更改的情况下工作得很好。

**C.3 引擎和工具代码没有重大修订**

我们在现有的工具上投入了大量的工程和艺术资源，不能对它们进行显著的改变。

我们也努力优化以下设计目标。

**M.1 最小化艺术家的迭代时间**

**M.2 最小的内容创建开销**

**M.3 最大化实现正交性**

## Existing and Alternative Solutions

Real-time Light Transport (dynamic lighting and geometry).实时光传输方法以运行时性能为代价，以最小的预计算支持动态照明和几何图形。在给定C.1和C.3约束条件下，在多光环境下实时路径跟踪和解决大量可见性问题仍然是不可行的。使用简化的场景体积表示是将几何体与光照计算解耦的常用方法，以减少光照和能见度计算时间，同时支持动态几何和光照。除了可观的运行时成本外，体积光传输方法的主要缺点在于用于照明的简化场景表示与场景几何形状之间的不匹配。实现没有泄漏或插值的一致性光照仍然是一个挑战。

Precomputed Light Transport (dynamic lighting, static geometry).预计算光传输(PRT)方法允许动态环境照明，同时保持运行时成本低。对场景几何结构施加了限制，在我们的环境中限制太大(C.2)，或者性能成本太高(C.1)。

Precomputed Lighting (static lighting and geometry).限制照明和几何图形是静态的，自然，运行时成本最小，并且是游戏制作中最常见的全局照明形式。通过预先计算多个照明场景并在运行时以增加的流存储成本为代价在它们之间插入，可以支持有限形式的动态照明。这些方法在光线变化有限且不受玩家控制的情况下非常有效，例如在改变一天的时间时。我们的全部动机是支持玩家驱动的照明改变到一个大的互动元素集。使用现有的技术将很快耗尽我们的内存预算，而为响应玩家输入而提供一套全新的照明是不可行的。

## Summary and overview

在性能约束下，没有任何一种现有的方法能够轻松满足我们的设计目标。因此，我们开发了自己的系统，基于预先计算的照明，使用混合的体积和光照映射表示，以获得最大的性能，同时支持动态几何变化，通过有效的本地照明更新。

“动态灯光设置”(DLSs)使我们能够根据玩家的动作打开或关闭几组灯光(章节3)，并相应地更新它们对全局照明的贡献。最后，在第4节中，我们扩展DLSs来处理照明中的非线性变化，比如打开和关闭门所产生的变化

# OUR BAKED GLOBAL ILLUMINATION SOLUTION

我们的照明解决方案有四个部分:我们如何表示(2.1节)和存储(2.2节)照明,我们如何预计算全局照明,我们假设关于水平几何(2.3节),以及我们如何使用预先计算的数据将全局照明阴影中静态和移动对象(2.4节)。

## Representing lighting

当为我们的照明数据选择表示时，我们有各种各样的选项。我们不仅要决定如何存储照明值，而且首先要决定存储哪些照明。

Path notation.

主光源LP (a)是我们系统中最常见的光源。对于这些，我们只烘焙间接照明，直接照明是按每像素的运行时计算的。

艺术家也可以放置静态光LS (b)，直接照明也可以被烘烤，这是在有很多灯光的地方做的，在运行时我们无法计算直接照明，特别是阴影。

此外，我们还支持从发光几何体LE (c)获得光照，同样，这在运行时评估太过昂贵，所以直接和间接的光照都被烘焙了。注意，这里的灯是无限小的光源，如点或聚光灯，而发光几何体是有发光材质的三角形。

最后，来自天空LSky (d)的任何光线，无论是直接还是间接，也将被烘烤，因为在运行时计算它将非常昂贵。

（1）

## Storage formats

Directional lighting encoding.我们在某些基础上存储入射辐射，例如球面谐波，它允许我们评估给定表面法线的辐照度。

Lightmaps.为了对光照数据进行编码，我们使用了一种环境高光方向(AHD)编码。光线贴图的空间分辨率由艺术家决定，以适应规定的内存预算。

Local Light Grids (LLGs).我们使用一种我们称之为“局部光网格”的数据结构，这是由Iwanicki和Sloan[2017]首次提出的，目的是提供光地图的体积替代。LLGs不尝试在物体表面存储光照值，而是将它们存储在模型周围的SH probe中。虽然Iwanicki和Sloan[2017]使用的是四面体网格，但我们决定使用更简单的欧几里得网格，以更快的查找速度和光线的完全解耦，使用一个有方向的边界框来表示模型周围的体积。

这种容量存储方法的主要问题是，由此产生的照明重建错过了模型表面可见性变化所引入的高频细节。LLGs通过为每个模型顶点存储一个额外的自可见性项来解决这个问题，并在从网格探针插入光照数据时考虑到它。将光照与可见性解耦的另一个好处是，无论模型在场景中的哪个位置，自可见性都保持不变。这允许使用实例化在许多场景位置渲染一个模型，因为每个实例的每个顶点数据是相同的，只有网格探针值在不同的实例之间改变。

The Global Light Grid (GLG).虽然系统中的动态对象不会影响全局光照，但我们仍然希望预先计算的全局光照能够影响移动的人物、车辆和粒子效果。处理这个问题的一种方法是引入一个体积照明表示，它允许我们在空间的任意点采样间接照明。这意味着移动的物体可以在任何位置评估静态照明。GLG的分辨率在地图上是可变的，并根据照明本身的分布和可用的游戏相关信息(例如，可玩区域分配更高分辨率的GLG)自动确定。密度最高的是每1.0米一个探针。我们使用传统的辐射探测器网格，分布在整个地图使用一个四面体网格[Cupisz 2012;Iwanicki和Sloan, 2017]。每个探针(包括GLG和LLG)以三阶球面谐波(SH)的基础存储辐射。对于任意点和法线，我们通过寻找最近的探针，插值它们的SH值，并用卷积计算法线的辐照度来计算间接光照。为了控制光泄漏，我们还存储每个四面体面粗糙的可见信息，并在插值时使用它来剔除不可见的探针[Iwanicki和Sloan, 2017]。体积效应直接取样GLG，而模型将GLG重新取样到每个模型的动态LLGs图集中。这样，照明查找的运行时实现对于静态和动态对象都是相同的，唯一的区别是存储在LLGs中的数据的来源。

## Baking via series expansion

我们的预计算使用蒙特卡罗射线跟踪

## Run-time shading

我们已经发布的三款游戏中，我们将LLG评估从顶点着色器移动到像素着色器，再回到顶点着色器。这是基于性能约束、几何图形提交管道中的效率改进以及每个标题上使用的内容的复杂性。

# INTERACTIVE LIGHTING UPDATES

在本节和接下来的章节中，我们将详细说明我们如何扩展这个系统以允许玩家驱动的动态照明更新。我们的目标是在保持静态解决方案的性能和内存特性的同时，进行最小限度的更改。我们还确保系统是可扩展的，并且能够支持复杂的照明更改，我们将在第4节中讨论。

## Dynamic Light Sets

在基础烘培中，动态灯光设置中的任何灯光都会被忽略，而一个单独的只启用相关的灯光的pass会执行。

在运行时,每个DLS都有一个关联的混合重量,ω。这个权重被计算为灯光组中灯光的平均强度。例如，考虑一个包含两盏灯的动态灯光组，每盏灯都以全强度照亮走廊。当其中一个是拍摄(它的强度设置为0),现在ω= 0.5,减半的直接照明贡献两个灯的光。最后照明用于阴影,L,然后就是一个线性组合的基础照明,磅,和每一个动态光贡献,ωj Sj,乘以各自的重量。

（2）

不幸的是，它非常昂贵，因此在下文中我们将讨论如何限制性能影响，以便将系统扩展到单个级别的数百个dls。

## Minimal overhead via sparse lighting storage

实际中，光集只对一个有限的区域有显著的贡献，如图3所示。为了利用这一点，我们使用稀疏的数据结构来存储动态灯光集的灯光值。基础烘培首先运行并存储所有接收者的数据。为了找到相关的接收器，每个动态光集通过我们的serie sexpansion baker计算直接光照和两次反射。然后，使用光源直接照射的texels的平均间接强度来计算阈值(实际上，我们使用平均值的1%)。任何接收器直接点燃或者强度高于阈值对于一个给定的光存储在更新记录集。这限制的最后记忆要求(见图4)和预先计算时间,最后聚集在数量级更多的射线样本。在烘烤过程中使用的稀疏照明数据结构很简单。对于每个活动接收器，我们存储一个索引，指向接收器在基础光贴图中的位置(对于texels)或GLG中相应的探测(对于GLG探测)。棘手的部分是保持性能的计算着色器在运行时高，并有尽可能少的辅助数据，这是我们在下面的部分处理。

##  Fast run-time combination of light sets

当动态光集的状态发生变化时，我们必须牢记以下约束。

(1)我们的解决方案必须是高效的GPU，这意味着可变的数据结构和不同的代码是有问题的。

(2)由于我们的有效负载数据非常小(每个lightmap texel 8字节)，我们必须保持任何偶然数据结构的内存开销很低。即使只是为每个texel存储一个额外的索引(4字节)，内存存储也会增加50%。

(3)常见的情况是DLS完全关闭，我们需要能够有效地跳过这些。

(4)类似地，我们需要能够跳过没有变化的dls的texel的更新。

(5)如果可能的话，我们想直接更新最终资源，避免的带宽开销。

Naive solutions. 生成最终光线贴图的一种自然方法是从每个texel的DLSs中收集数据。这类似于，例如，矩阵调色板皮肤。每个texel/LG(4字节地址)存储重叠的DLS的数量(1字节)，对于每个重叠它也需要存储索引(1字节)和照明数据(8/28字节LM/LG)。这种表示方法有两个问题,使其不可行:它是可变长度/特塞尔绵羊,这意味着索引它我们需要存储一些基地址(甚至更多的内存开销——另一个4字节),它就会发散在着色器(变量循环长度),很难跳过有效工作,如果所有的DLS给定特塞尔绵羊没有改变。

第二种简单的方法是将每个DLS单独存储，并将数据分散到最终的光照图中。这将要求对目标texel/LG地址进行冗余存储，并对最终资源进行读-修改-写访问，但这会使混合索引隐式，并具有固定的跨步。另外一个好处是，如果DLS没有变化或为零，我们可以很容易地跳过工作，但只有当我们增量地进行混合时才会导致数值精度问题。如果我们想要确定性的混合排序，我们将需要更新任何具有非零混合的texel，这是不能对每个DLS推理的。

Our approach. 我们的技术牢牢地夹在上面讨论的两种天真的解决方案之间，结合了两者的优点。我们不考虑单独的texel或单独的DLSs，而是根据它们在预处理步骤中受到的光集对texel进行聚类。这给了我们一个光集组合列表，每个光集都有一组受影响的texel。然后我们可以为每个组合生成一个GPU计算调度。这满足了上面列出的所有约束条件。在调度中，源信息(光线被设置为混合)保持不变，因此对于每个目标texel都是相同的。这意味着我们不需要可变长度的数据结构，避免代码执行的发散，每个texel不存储冗余数据。很容易检测给定分派的任何相关灯光设置是否关闭，并确保跳过混合这些。此外，如果调度的灯光设置没有任何更改，我们可以完全跳过它。最后，我们不需要任何读-修改-写资源。每个texel只属于一个分派，因此写入一次。尽管这种技术在概念上是合理的，而且性能很好，但是在实践中，我们需要做额外的考虑，并且随着照明艺术家开始更广泛地使用DLSs，这些需要进一步发展。特别地，为每个唯一的光集组合创建一个分派会导致分派包含很少的texels，从而导致较差的GPU利用率和较高的每分派开销。如果有受多种灯光影响的texels，这一点尤其正确。

Evolution. 在开发第一款游戏时，设计师们被要求将DLS的数量保持在个位数，并尝试不超过3次重叠。我们创建了专门的着色器来复制备份数据(都是零)和1-3个重叠。此外，还有一个回退着色器，用于有更多重叠的texel，或者在分派太小的情况下使用。这个着色器复制到一个完整的float_32 scratch缓冲区(它总是可以在我们的目标硬件上做读-修改-写操作)，循环遍历重叠，对它们进行排序，以最小化索引的数量。回退材质并不是特别快,但这是不需要经常——一个常见的场景是一个房间,灯光会闪烁或关闭(所有在同一DLS),它连接到隧道,一个DLS,可能同样闪烁/关闭。这导致大型区域与一组和2 DLS重叠隧道遇到一个房间。

第一步，我们增加了专门的着色器的数量来处理被多达8个动态光设置影响的纹理。为了消除回退着色器，我们引入了两个不那么专业的着色器:

(1)分派中的每个texel都有相同数量的重叠，但是DLSs可以不同。它们不能被“降级”，如果分派中的任何DLS被更改，则必须运行整个DLS集。这是针对小于固定大小(最多128个texel)的DLS组合所做的，允许我们将它们打包在一起，有更少的总体分派，但做一些不必要的工作。所有少于5个DLSs的重叠都在这些着色器中处理。

(2)两个最后的度假村着色器，一个用于5-8重叠，一个用于9-16重叠。这些交错一个特塞尔绵羊的数据,计算“起始地址相对于集群开始(uint16_t)”,他们存储基础指数每批16/8 texel(所以平摊到1/2位),和2/3位/特塞尔绵羊“计数”相对于基地(5、9所以它适合在2/3比特)。然后我们只需要在使用基本索引之前计算2/3位数字的前缀和。这使得每个texel的开销为3/5位，并使数据和代码的差异最小化。当这些分派发生集群重叠时，我们的目标是最小化分派中DLSs的总数，因为如果任何一个DLSs发生更改，整个分派都必须执行。

#  MULTI-STATE GEOMETRY

我们试图将其扩展到更复杂的交互作用。遵循与之前相同的游戏设计驱动方法，我们决定解决打开和关闭门户的具体问题。在第一人称射击游戏中，门通常作为一种控制玩家进程的方式。通过让非玩家角色打开大门，游戏设计师可以设定故事的节奏并引导玩家通过复杂的关卡。这意味着玩家的注意力往往会转向一扇打开的门。抬头看着在黑暗水平与室内房间和明亮的外观这灯光艺术家而言都是个挑战,如光流经门是重要的(参见图6)。到目前为止艺术家必须决定是否关闭大门在烘烤过程中(离开房间黑暗游戏期间甚至当门打开),或删除它(和最终光泄漏通过那扇关闭的门)。他们可以添加脚本运行时灯光来“欺骗”反弹，但这既耗时又昂贵。下面，我们将介绍如何扩展动态灯光设置系统，使之能够在不过度影响烘烤时间性能的情况下使用动态门。

## Doors as dynamic light sets

当打开一扇门作为基础照明的附加组件时，如何表达灯光的变化是一个挑战。我们想要到达一组贡献每门,SP,可以控制线性的计算重量ωP在运行时基于当前的张角的门。

Preliminary assumptions. 为了实现这一点，我们做了几个简化假设。当门通过场景移动到“关闭”和“打开”两种状态时，我们减少了复杂的非线性照明变化。在“关闭”状态下，门模型处于完全关闭的位置，而在“打开”状态下，我们完全忽略模型。另一种选择是将它放置在一些“开放”的位置，但是我们的层次中的许多门既向外也向内开放，并且没有一个明确的“开放”位置。此外，我们不考虑任何在门关闭状态下反弹的光线。计算它将需要移除门打开时的灯光，这与我们的动态灯光设置系统不直接兼容。虽然有一些相对容易的方法来实现这一点，但我们并没有发现缺少反弹光的意义。最后，当在一个带有多个门或动态灯光设置的关卡中进行动态照明时，我们必须选择场景中其他所有交互元素的状态。这并不是动态灯光设置本身的问题。在这里，照明是线性相加的，任何单独的照明集的贡献不受是否启用另一个照明的影响。但是在门的情况下，一扇门是否打开会非线性地影响光从动态光组和其他门的传播。为了得到n个DLSs和m个门的正确结果，我们必须烘焙所有(1+n)2 m种状态组合，但这很快就变得棘手起来。门之间的距离通常相对较远。所以在使用这种技术发布最后一款游戏时，我们假设对于每一个动态灯光设置和门烘焙，所有其他的门都是关闭的。这将组合的数量减少到只有(n + m + 1).当然，所有这些简化都会在某些情况下导致人为现象，我们将在6.2节中讨论这些问题以及可能的解决方案。

Describing door paths. 

## Efficient sampling techniques

为了减少烘培时间，我们将自己限制在特定的路径子集中，我们观察到这些路径对整体光照的贡献最大，我们在图7中显示了这些路径。也就是说，我们计算任何直接通过门的光线和它的第一次反射。因此，我们希望既引导聚集光线到门直接和地区被强烈照亮通过门。请注意，这里直接通过门并不等同于直接照明。也就是说，除了连接到光源之外，我们还想考虑到门另一侧的几何体的反射光线。幸运的是，我们可以使用在基本烘焙过程中计算出的大部分信息来实现这一点。例如，当穿过门的光线击中另一侧的光映射模型时，我们可以简单地对存储的间接光线进行采样。

The door as an area light source. 对于靠近门的接收者，许多贡献路径为LD+PR形式。如图7 (a)所示，直接从发射器一侧到达，接收器一侧不反弹。对于靠近框架的地板上的接收器，门支承一个大的实心角。在这些情况下，开门形成一个(复杂的)区域光源。为了计算这个贡献，我们使用分层采样器在门的定向包围盒上绘制点，并向它们投射光线。门的立体角越大，我们分配给这个部分的光线就越多。这类似于在离线绘制中使用的门户采样策略[Bitterli et al. 2015]，但是除了引导光线进入门户之外，这些方法还考虑了流经门户的光照方向分布。不幸的是，这在我们的场景中非常复杂。与采样环境地图不同，到达接收器的光照不仅取决于方向，还取决于它相对于传送门的位置。我们尝试使用光场重要度采样策略[Lu et al. 2014]来更好地将样本分布在门的边界盒上，但发现方差差异极小。

Clustered shadow photons for path guiding. 

