# The design and evolution of the UberBake light baking system

UberBake是一款由动视公司开发的GI系统，它支持有限的照明变化以回应特定玩家的互动。我们不依赖于完全动态的解决方案，而是使用传统的静态光照烘培流水线，并通过一组小特性扩展它，使我们能够在运行时以最小的性能和内存开销动态更新预先计算的光照。我们展示了如何有效地预先计算由于单个灯的启用和禁用以及门的开启和关闭而引起的照明变化。

# INTRODUCTION

渲染过程的难点之一是计算全局光照——不是直接来自光源，而是经过场景中其他表面的一些反射后到达每个点的光照成分。考虑到有限的时间预算，大多数现代游戏引擎都依赖于某种形式的预计算或烘焙。实时光线追踪不太可能取代当前基于烘烤的解决方案，甚至不太可能普遍使用，至少在下一代主机上(对于移动平台可能会更久)。然而，烘培照明的局限性是显著的。任何几何图形的改变都需要花费大量的离线更新，这通常会花费数小时，大大增加了艺术家的迭代时间。因为预先计算是在假定静态层次几何图形的情况下执行的，所以运行时的任何更改都不会对光照产生影响。例如，一个玩家可能会破坏一堵墙，而这堵墙应该会让光线充满建筑内部;然而，由于照明是预先计算与墙壁完整，没有可用的信息，关于如何在房间内的照明分布应改变时，它不再在那里。即使是像打开门这样简单的交互也可能会使关卡的灯光处于不一致的状态。

UberBake是在多次发行的过程中开发出来的，创新主要是由游戏玩法和关卡设计需求驱动的。

我们工作的核心观点是，我们可以选择影响照明(启用/禁用灯和打开/关闭门)的用户交互的有限子集，并从一个完全动态的GI解决方案中获得许多好处。这使得1)有效地预先计算与每个交互相关的光照变化，2)实现一个运行时系统，平均来说，不会比我们之前的完全静态实现慢，并使用最小的额外内存，它与允许的交互数量线性扩展。

## 设计标准

**C.1 接近于零的运行时开销**

我们希望在各种各样的硬件上发行60帧/秒的游戏，从现代游戏pc到控制台和智能手机。

**C.2 没有附加的几何约束**

当我们实现我们的系统时，已经有了大量的内容。因为重做大部分内容是不可行的，所以系统必须在只需要少量级别更改的情况下工作得很好。

**C.3 引擎和工具代码没有重大修订**

我们在现有的工具上投入了大量的工程和艺术资源，不能对它们进行显著的改变。

我们也努力优化以下设计目标。

**M.1 最小化艺术家的迭代时间**

**M.2 最小的内容创建开销**

**M.3 最大化实现正交性**

## Existing and Alternative Solutions

Real-time Light Transport (dynamic lighting and geometry).实时光传输方法以运行时性能为代价，以最小的预计算支持动态照明和几何图形。在给定C.1和C.3约束条件下，在多光环境下实时路径跟踪和解决大量可见性问题仍然是不可行的。使用简化的场景体积表示是将几何体与光照计算解耦的常用方法，以减少光照和能见度计算时间，同时支持动态几何和光照。除了可观的运行时成本外，体积光传输方法的主要缺点在于用于照明的简化场景表示与场景几何形状之间的不匹配。实现没有泄漏或插值的一致性光照仍然是一个挑战。

Precomputed Light Transport (dynamic lighting, static geometry).预计算光传输(PRT)方法允许动态环境照明，同时保持运行时成本低。对场景几何结构施加了限制，在我们的环境中限制太大(C.2)，或者性能成本太高(C.1)。

Precomputed Lighting (static lighting and geometry). 限制照明和几何图形是静态的，自然，运行时成本最小，并且是游戏制作中最常见的全局照明形式。我们不能使用任何这些技术，因为它们不允许任何动态光照变化。通过预先计算多个照明场景并在运行时以增加的流存储成本为代价在它们之间插入，可以支持有限形式的动态照明。这些方法在光线变化有限且不受玩家控制的情况下非常有效，例如在改变一天的时间时。在那里，流负载很容易预测，并且最多需要在内存中保存两组不同的照明。我们的全部动机是支持玩家驱动的照明改变到一个大的互动元素集。使用现有的技术将很快耗尽我们的内存预算，而为响应玩家输入而提供一套全新的照明是不可行的。

## Summary and overview

在性能约束下，没有任何一种现有的方法能够轻松满足我们的设计目标。因此，我们开发了自己的系统，基于预先计算的照明，使用混合的体积和光照映射表示，以获得最大的性能，同时支持动态几何变化，通过有效的本地照明更新。

“动态灯光设置”(DLSs)使我们能够根据玩家的动作打开或关闭几组灯光(章节3)，并相应地更新它们对全局照明的贡献。最后，在第4节中，我们扩展DLSs来处理照明中的非线性变化，比如打开和关闭门所产生的变化

# OUR BAKED GLOBAL ILLUMINATION SOLUTION

我们的照明解决方案有四个部分:我们如何表示(2.1节)和存储(2.2节)照明,我们如何预计算全局照明,我们假设关于水平几何(2.3节),以及我们如何使用预先计算的数据将全局照明阴影中静态和移动对象(2.4节)。

## Representing lighting

当为我们的照明数据选择表示时，我们有各种各样的选项。我们不仅要决定如何存储照明值，而且首先要决定存储哪些照明。

Path notation.主光源LP (a)是我们系统中最常见的光源。对于这些，我们只烘焙间接照明，直接照明是按每像素的运行时计算的。艺术家也可以放置静态光LS (b)，直接照明也可以被烘烤，这是在有很多灯光的地方做的，在运行时我们无法计算直接照明，特别是阴影。此外，我们还支持从发射几何体LE (c)获得光照，同样，这在运行时评估太过昂贵，所以直接和间接的光照都被烘烤了。注意，这里的灯是无限小的光源，如点或聚光灯，而发射是三角形的发射材料。最后，来自天空LSky (d)的任何光线，无论是直接还是间接，都将被烘烤，因为在运行时计算它将非常昂贵。

（1）

## Storage formats

Directional lighting encoding.我们在某些基础上存储入射辐射，例如球面谐波，它允许我们评估给定表面法线的辐照度。

Lightmaps.为了对光照数据进行编码，我们使用了一种环境高光方向(AHD)编码。光线贴图的空间分辨率由艺术家决定，以适应规定的内存预算。

Local Light Grids (LLGs).我们使用一种我们称之为“局部光网格”的数据结构，这是由Iwanicki和Sloan[2017]首次提出的，目的是提供光地图的体积替代。LLGs不尝试在物体表面存储光照值，而是将它们存储在模型周围的SH辐射探测器中。虽然Iwanicki和Sloan[2017]使用的是四面体网格，但我们决定使用更简单的欧几里得网格，以更快的查找速度和光线的完全解耦，使用一个有方向的边界框来表示模型周围的体积。

这种容量存储方法的主要问题是，由此产生的照明重建错过了模型表面可见性变化所引入的高频细节。LLGs通过为每个模型顶点存储一个额外的自可见性项来解决这个问题，并在从网格探针插入光照数据时考虑到它。将光照与可见性解耦的另一个好处是，无论模型在场景中的哪个位置，自可见性都保持不变。这允许使用实例化在许多场景位置渲染一个模型，因为每个实例的每个顶点数据是相同的，只有网格探针值在不同的实例之间改变。

The Global Light Grid (GLG).但是我们缺少一种方法来阴影移动的对象。虽然系统中的动态对象不会影响全局光照，但我们仍然希望预先计算的全局光照能够影响移动的字符、车辆和粒子效果。处理这个问题的一种方法是引入一个体积照明表示，它允许我们在空间的任意点采样间接照明。这意味着移动的物体可以在任何位置评估静态照明。GLG的分辨率在地图上是可变的，并根据照明本身的分布和可用的游戏相关信息(例如，可玩区域分配更高分辨率的GLG)自动确定。密度最高的是每1.0米一个探针。我们使用传统的辐射探测器网格，分布在整个地图使用一个四面体网格[Cupisz 2012;Iwanicki和Sloan, 2017]。每个探针(包括GLG和LLG)以三阶球面谐波(SH)的基础存储辐射。对于任意点和法线，我们通过寻找最近的探针，插值它们的SH值，并用卷积计算法线的辐照度来计算间接光照。为了控制光泄漏，我们还存储每个四面体面粗糙的可见信息，并在插值时使用它来剔除不可见的探针[Iwanicki和Sloan, 2017]。体积效应直接取样GLG，而模型将GLG重新取样到每个模型的动态LLGs图集中。这样，照明查找的运行时实现对于静态和动态对象都是相同的，唯一的区别是存储在LLGs中的数据的来源。

## Baking via series expansion

我们的预计算使用蒙特卡罗射线跟踪

## Run-time shading

我们已经发布的三款游戏中，我们将LLG评估从顶点着色器移动到像素着色器，再回到顶点着色器。这是基于性能约束、几何图形提交管道中的效率改进以及每个标题上使用的内容的复杂性。

# INTERACTIVE LIGHTING UPDATES

在本节和接下来的章节中，我们将详细说明我们如何扩展这个系统以允许玩家驱动的动态照明更新。我们的目标是在保持静态解决方案的性能和内存特性的同时，进行最小限度的更改。我们还确保系统是可扩展的，并且能够支持复杂的照明更改，我们将在第4节中讨论。

## Dynamic Light Sets

在基础烘培中，动态灯光设置中的任何灯光都会被忽略，而一个单独的通道只会启用相关的灯光。

在运行时,每个DLS都有一个关联的混合重量,ω。这个权重被计算为灯光组中灯光的平均强度。例如，考虑一个包含两盏灯的动态灯光组，每盏灯都以全强度照亮走廊。当其中一个是拍摄(它的强度设置为0),现在ω= 0.5,减半的直接照明贡献两个灯的光。最后照明用于阴影,L,然后就是一个线性组合的基础照明,磅,和每一个动态光贡献,ωj Sj,乘以各自的重量。

（2）

不幸的是，它非常昂贵，因此在下文中我们将讨论如何限制性能影响，以便将系统扩展到单个级别的数百个dls。

## Minimal overhead via sparse lighting storage

实际中，光集只对一个有限的区域有显著的贡献，如图3所示。为了利用这一点，我们使用稀疏的数据结构来存储动态灯光集的灯光值。基础烘培首先运行并存储所有接收者的数据。为了找到相关的接收器，每个动态光集通过我们的seriesexpansion baker计算直接光照和两次反射。然后，使用光源直接照射的texels的平均间接强度来计算阈值(实际上，我们使用平均值的1%)。任何接收器直接点燃或者强度高于阈值对于一个给定的光存储在更新记录集。这限制的最后记忆要求(见图4)和预先计算时间,最后聚集在数量级更多的射线样本。在烘烤过程中使用的稀疏照明数据结构很简单。对于每个活动接收器，我们存储一个索引，指向接收器在基础光贴图中的位置(对于texels)或GLG中相应的探测(对于GLG探测)。棘手的部分是保持性能的计算着色器在运行时高，并有尽可能少的辅助数据，这是我们在下面的部分处理。

##  Fast run-time combination of light sets