# Global Illumination

## The Rendering Equation

在实时渲染中，通常只使用局部光照模型。只需要可见点的表面数据就可以计算光照——而这正是gpu最有效地提供的。原语被独立地处理和栅格化，然后被丢弃。在执行在点b的计算时，不能访问点a的照明计算结果。透明度、反射和阴影是全局照明算法的例子。他们使用来自其他物体的信息，而不是被照亮的物体。这些效果大大增加了渲染图像的真实感，并提供线索，帮助观众理解空间关系。同时，它们的模拟也很复杂，可能需要预计算或呈现多个通道来计算一些中间信息。

[Fig 11.2]

[Tab 11.1]

全局照明研究的重点是计算沿着这些路径光传输的方法。当将其应用于实时渲染时，我们常常愿意牺牲一些质量或正确性来进行有效的评估。最常见的两种策略是简化和预先计算。例如，我们可以假设所有的光线在到达眼睛之前都是漫反射的，这种简化可以很好地适用于某些环境。我们还可以离线预先计算一些关于对象间效果的信息，例如生成纹理来记录表面上的照明水平，然后实时地只执行依赖于这些存储值的基本计算。本章将举例说明如何使用这些策略来实现实时的各种全局照明效果。

## General Global Illumination

求解完整渲染方程的算法可以生成令人惊叹的、照片般逼真的图像(图11.3)。但是，对于实时应用程序来说，这些方法的计算开销太大了。那么，为什么要讨论它们呢?

第一个原因是，在静态或部分静态的场景中，这样的算法可以作为预处理运行，存储结果以供渲染期间使用。例如，这是游戏中常见的方法，我们将讨论这类系统的不同方面。

第二个原因是全局光照算法是建立在严格的理论基础上的。它们是直接从渲染方程推导出来的，它们所做的任何近似都会被仔细地分析。在设计实时解决方案时，可以并且应该使用类似的推理方法。即使我们走了捷径，我们也应该知道结果是什么，正确的方法是什么。随着图形硬件变得越来越强大，我们将能够做出更少的妥协，并创建更接近正确物理结果的实时呈现图像。

求解绘制方程的两种常用方法是有限元法和蒙特卡罗法。Radiosity是基于第一种方法的算法;各种形式的射线追踪使用第二种方法。

### Radiosity

关于这个算法已经有很多书了[76,275,1642]，但是其基本思想相对简单。光在环境中反射。你打开一盏灯，照明很快达到平衡。在这种稳定状态下，每个表面都可以被看作是一个光源。基本的辐射算法做了一个简化的假设，即所有的间接光都来自漫反射表面。这个前提不适用于有抛光大理石地板或墙上有大镜子的地方，但对于许多建筑设置来说，这是一个合理的近似。辐射可以遵循一个有效的无限数量的漫反射。使用本章开始介绍的符号，它的轻传输集是LD E。

假设每个表面都由若干个小块组成。对于每个较小的区域，它计算单个的平均辐射值，因此这些小块需要足够小，以捕获所有的照明细节(例如阴影边缘)。但是，它们不需要一对一地匹配底层曲面三角形，甚至不需要在大小上一致。

我们可以推导出第i块的辐射

【11.4】

B i为patch i的辐射度，为辐射度，即补丁我发出的热辐射,ρss是subsurface反照率(9.3节)。只有光源的发射才是非零的。F ij是patch i和j之间的形状因子，形状因子定义为

【11.5】

其中A i是patch i的面积，V (i, j)是点i和点j之间的可见性函数，

【fig 11.4】

radiosity算法的一个重要部分是准确地确定场景中成对patch之间的形状因子。

根据计算得到的形式因子，将所有patch的方程(方程11.4)合并成一个单一的线性系统。然后对系统进行求解，得到每个patch的辐射值。随着补丁数量的增加，由于计算复杂性高，减少这样一个矩阵的成本是相当大的。

由于该算法可伸缩性差且有其他限制，因此很少使用经典的光线来生成照明解决方案。然而，这种预先计算形式因子并在运行时使用它们进行某种形式的光传播的思想在现代实时全球照明系统中仍然很流行。

### Ray Tracing

路径跟踪的唯一缺点是实现高视觉保真度所需的计算复杂性。对于电影质量的图像，可能需要追踪数十亿条路径。已经提出了许多方法来对抗这种效应，而不需要跟踪其他路径。一种流行的技术是重要性抽样。其原理是，通过向大多数光线的照射方向发射更多光线，可以大大减少方差。

## Ambient Occlusion

我们将以最简单的，但在视觉上仍然令人信服的解决方案开始我们的实时替代探索，并逐步建立更复杂的效果贯穿整个章节。

一种基本的全局照明效果是环境光遮蔽(AO)。这种技术是由工业光魔公司(Industrial Light & Magic)的Landis[974]在21世纪初开发的，目的是改善电影《珍珠港》(Pearl Harbor)中电脑生成飞机上的环境照明质量。尽管这种效应的物理基础包含了相当多的简化，但其结果却令人惊讶地似是而非。这种方法在光线缺乏方向性变化且不能显示物体细节的情况下，提供了关于形状的廉价线索。

### Ambient Occlusion Theory

环境光遮蔽的理论背景可以直接从反射方程推导出来。为了简单起见，我们将首先关注Lambertian表面。从这些表面发出的L o照度与表面辐照度e成正比。辐照度是入射照度的余弦加权积分。一般情况下，它取决于表面位置p和表面法向n。同样，为了简单起见，我们假设入射光为常数，对于所有入射方向L, L i (L) = L A，从而得到计算辐照度的公式:

【11.6】

在恒定均匀照度的假设下，辐照度(以及输出的辐照度)不依赖于表面位置或法线，而是在物体上保持恒定。这导致了扁平的外观。

方程11.6没有考虑任何可见性。有些方向可能会被物体的其他部分或场景中的其他物体挡住。这些方向将有不同的入射亮度，而不是亮度。为简单起见，我们将假设来自阻塞方向的传入辐射为零。这忽略了所有可能从场景中其他物体反射的光，并最终从这些被阻挡的方向到达点p，但它极大地简化了推理。因此，我们得到了由Cook和Torrance[285,286]首先提出的方程:

【11.7】

【Fig 11.7】

能见度函数的归一化余弦加权积分称为环境遮挡:

【11.8】

【11.9】

除了k A, Landis[974]还计算了一个平均的未闭合方向，称为弯曲法线。这个方向向量被计算为无阻挡光方向的余弦加权平均值:

【11.10】

【Fig 11.8】

### Visibility and Obscurance

需要仔细定义用于计算环境遮挡因子k A(等于11.8)的可见性函数v(l)。

不幸的是，对于封闭的几何图形来说，可见性函数方法是失败的。想象一个场景，其中有一个封闭的房间，里面有各种各样的物品。所有的表面的k值都是0，因为所有来自表面的射线都会撞击到某物。经验方法试图重现环境遮挡的外观，但不一定要模拟物理可见性，通常在这类场景中效果更好。

一些方法受到Miller的accessibility shading可达性阴影概念的启发[1211]，该概念模拟了表面的角落和缝隙如何捕捉污垢或腐蚀。

茹科夫等。[1970]引入了obscurance的概念,修改环境闭塞的计算用距离映射函数ρ(l)代替可见度函数v(左)。

【11.11】

与v (l),只有两个有效值,1没有交集和0 - tersectionρ(l)是一个连续函数基于射线相交前表面传播的距离。

【Fig 11.9】

尽管试图证明它的物理基础上，掩盖是不正确的物理。然而，它经常给出貌似合理的结果，符合观众的期望。缺点之一是需要手动设置d max的值以获得令人满意的结果。这种妥协经常出现在计算机图形学中，其中一种技术没有直接的物理基础，但“具有感知上的说服力”。目标通常是一个可信的图像，所以这样的技术是可以使用的。也就是说，基于理论的方法的一些优点是它们可以自动工作，并且可以通过对现实世界如何工作的推理进一步改进。

### Accounting for Interreflections

尽管环境光遮蔽产生的结果在视觉上是令人信服的，但它们比全全局照明模拟产生的结果要暗。

【Fig 11.10】

环境遮挡和全全局照明之间的差异的一个重要来源是互反射。公式11.8假设被阻挡方向上的辐射为零，而在现实中，相互反射会从这些方向引入非零辐射。这个差异可以通过增加ka的值来解决。或者obscurance distance mapping function。

以更精确的方式跟踪相互反射是昂贵的，因为它需要解决递归问题。

Stewart和Langer[1699]提出了一种不贵但精确得惊人的近似互反射的方法。这是基于在漫射照明下的Lambertian场景的观察，从给定位置可见的表面位置往往具有相似的亮度。通过假设遮挡方向的辐射强度L i等于当前阴影点的输出辐射强度L o，分解递推，可以得到一个解析表达式:

【11.12】

【11.13】

这个方程将趋向于使环境光遮蔽因子变亮，使它在视觉上更接近全局照明解决方案的结果，包括互反射。效果是高度依赖于ρss的值。基本的近似假设表面颜色在阴影点附近是相同的，从而产生类似color bleeding的效果。

### Precomputed Ambient Occlusion

环境遮挡因子的计算可能会很耗时，而且通常在渲染之前离线完成。预先计算任何与光线有关的信息(包括环境光阻)的过程通常称为烘焙。

计算环境遮挡最常用的方法是蒙特卡罗方法。光线投射并检查与场景的交点，对方程11.8进行数值计算。例如，假设我们随机选取N个方向l均匀分布在正常N周围的半球上，并在这些方向上追踪射线。基于相交结果，我们对可见性函数v进行了评估，环境遮挡可以计算为

【11.14】

环境光阻预计算可以在CPU上进行，也可以在GPU上进行。大多数商业上可用的建模和渲染软件包提供了一个预先计算环境光遮蔽的选项。

遮挡数据对于对象上的每个点都是唯一的。它们通常存储在纹理、卷或网格顶点中。不同存储方法的特点和问题是相似的，不管存储的是什么类型的信号。同样的方法可以用于存储环境光遮蔽、方向光遮蔽或预先计算的照明，如11.5.4节所述。

预先计算的数据也可以用来模拟物体相互之间的环境遮挡效应。Kontkanen和Laine[924,925]将一个对象对其周围环境的环境遮挡效应存储在一个立方体映射中，称为环境遮挡场。他们用二次多项式的倒数来模拟环境光遮蔽值随距离物体的变化。它的系数存储在一个立方体映射中，以模拟遮挡的方向变化。在运行时，利用被遮挡对象的距离和相对位置获取合适的系数，重建遮挡值。

无论我们选择哪种方法来存储环境遮挡值，我们都需要知道我们是在处理一个连续信号。当我们从空间中的一个特定点发射射线时，我们进行采样，当我们在着色之前从这些结果中插入一个值时，我们重建。所有来自信号处理领域的工具都可以用来提高采样-重建过程的质量。

来自育碧的《刺客信条》[1692]和《孤岛惊雷》[1154]系列也使用了一种预先计算的环境光遮蔽来增强其间接照明解决方案。它们从自顶向下的视图呈现世界，并处理生成的深度图来计算大规模的遮挡。根据相邻深度样本的分布情况，采用各种启发式方法对该值进行估计。通过将世界空间的位置投射到纹理空间，生成的世界空间AO地图应用于所有对象。他们称这个方法为World AO。

### Dynamic Computation of Ambient Occlusion

对于静态场景，可以预先计算环境遮挡因子ka和弯曲法向n弯曲。然而，对于物体移动或改变形状的场景，可以通过动态计算这些因素来获得更好的结果。这样做的方法可以分为在对象空间中操作的方法和在屏幕空间中操作的方法。

离线计算环境光遮蔽的方法通常包括从每个表面点向场景投射大量的光线，数十到数百，并检查交叉。这是一个昂贵的操作，实时方法关注的是近似或避免大量计算的方法。

Bunnell[210]通过将曲面建模为放置在网格顶点上的圆盘形元素的集合，计算环境遮挡因子ka和弯曲法线n。之所以选择磁盘，是因为可以通过分析计算一个磁盘与另一个磁盘之间的遮挡，从而避免了投射光线的需要。但是还有一些问题详细信息要参考【文献】。

计算每对元素之间的遮挡是一个O(n 2)阶操作，除了最简单的场景外，这对于其他所有场景都太昂贵了。通过使用简化的曲面表示方法，可以降低成本。Bunnell构造了一个分层的元素树，其中每个节点都是一个磁盘，表示树中低于它的磁盘的聚合。当执行磁盘间遮挡计算时，更高级别的节点用于更远处的表面。这将计算减少到O(n log n)阶，这更加合理。

Evans[444]描述了一种基于符号距离场(SDF)的动态环境遮挡逼近方法。莱特[1910]进一步扩展了在环境光遮蔽中使用符号距离场的方法。Wright执行锥跟踪，而不是使用特定的启发式方法来生成遮挡值。

【Fig 11.12】

Crassin等人[305]在场景的体素表示上下文中描述了类似的方法。他们使用一个稀疏体素八叉树(章节13.10)来存储场景的体素化。他们的计算环境光遮蔽的算法是渲染全局照明效果的更一般方法的一个特例(章节11.5.7)。

Ren等人[1482]将咬合几何近似为一个球体集合(图11.13)。用球谐函数表示被单球遮挡的表面点的可见性函数。

【Fig 11.13】

其他方法具体参考【文献】。

### Screen-Space Methods

对象空间方法的开销与场景复杂度成正比。然而，一些关于遮挡的信息完全可以从屏幕空间数据中推断出来，比如深度和法线。这种方法的成本是恒定的，与场景的细节无关，而只与渲染所用的分辨率有关。

Crytek开发了一种用于Crysis的动态屏幕空间环境闭塞(SSAO)方法[1227]。他们使用z- buffer作为唯一的输入，以全屏方式计算环境光阻。每个像素的环境遮挡因子k A是通过测试一组点来估计的，这些点分布在像素位置周围的一个球面上，对z-buffer进行测试。k A的值是z缓冲区中对应值前面的样本个数的函数。通过的样本数量越少，k A的值就越低。参见图11.14。样本的权值随着距离像素的距离的增加而减小，类似于模糊系数[1970]。注意，由于样本没有使用(n·l) +因子加权，因此产生的环境遮挡是不正确的。而不是只考虑那些在地表以上半球的样本，所有的都被计算和考虑在内。这种简化意味着表面以下的样本在它们不应该被计数的时候被计数。这样做会导致平面变暗，边缘比周围更亮。尽管如此，结果往往是赏心悦目的。参见图11.15。

【Fig 11.14】

【Fig 11.15】

这两种方法的极端简单性很快被工业界和学术界注意到，并产生了大量后续工作。许多方法，如Filion等人[471]在《星际争霸2》中使用的方法和McGuire等人[1174]使用的可伸缩环境模糊法，都使用特定的启发式方法来生成遮挡因子。这些方法具有良好的性能特点，并公开了一些参数，可以手工调整，以达到预期的艺术效果。

其他方法的目的是提供更有原则的方法来计算遮挡。Loos和Sloan[1072]注意到Crytek的方法可以解释为蒙特卡罗积分。他们将计算值称为体积模糊，并将其定义为

【11.15】

其中X是一个三维的,球面点附近,ρ是distance-mapping函数,类似于,方程11.11 d的距离函数,和o (X)是入住率函数,等于零如果X不占领,否则。他们指出,ρ(d)功能没有影响最终的视觉质量,因此使用一个常数函数。在这个假设下，体积模糊是点附近的占用函数的积分。Crytek的方法是对三维邻域随机采样，对样本内的邻域进行评价。Loos和Sloan通过随机采样一个像素的屏幕空间邻域来计算x维的数值积分。

