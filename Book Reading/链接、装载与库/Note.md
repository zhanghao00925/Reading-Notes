传统意义上将用于管理计算机本身的软件称为系统软件。系统软件可以分成两块，一块是平台性的，比如操作系统内核、驱动程序、运行库和数以千计的系统工具；另一块是用于程序开发的，比如编译器、汇编器、链接器等开发工具和开发库。

运行库使用操作系统提供的系统调用接口（System call Interface），系统调用接口在实现中往往以软件中断（Software Interrupt）的方式提供。
 
我们 把虚拟空间的页就叫做虚拟页（VP，Virtual Page），把物理内存中的页叫做物理页（PP，Physical Page），把磁盘中的页叫做磁盘页（DP，Disk Page）。
 
虚拟存储的实现需要依靠硬件支持，几乎所有的硬件都采用一个叫MMU（Memory Managerment Unit）的部件来进行页映射。图1
 
线程（Thread），有时被称为轻量级进程（LightweightProcess，LWP），是程序执行流的最小单元。一个标准的线程由线程ID、当前指令指针（PC）、寄存器集合和堆栈组成。一个进程由一个到多个线程组成，各个线程之间共享程序的内存空间（包括代码段、数据段、堆等）及一些进程级的资源（如打开文件额信号）。图2

线程也拥有自己的私有空间，包括栈，线程局部存储（Thread Local Storage，TLS），寄存器。图3

我们一般把频繁等待的线程称之为IO密集型线程（IO Bound Thread），而把很少等待的线程称为CPU密集型线程（CPU Bound Thread）。IO密集型线程总是比CPU密集型线程容易得到优先级的提升。

Linux将所有的执行实体都称为任务（Task），每一个任务概念上都类似于一个单线程的进程。不同的任务之间可以选择共享内存空间。

一个任务被重入，表示这个函数没有执行完成，由于外部因素或内部调用，又一次进入该函数执行。有两种情况：
1. 多个线程同时执行这个函数。
2. 函数自身（可能是经过多层调用之后）调用自身。
可重入函数需要满足：
1. 不使用任何（局部）静态或全局的非const变量。
2. 不返回任何（局部）静态或全局的非const变量的指针。
3. 仅依赖于调用方提供的参数。
4. 不依赖任何单个资源的锁（mutex等）。（？）
5. 不依赖任何不可重入的函数。
可重入是并发安全的强力保障，可以在多线程环境下放心使用。

可以使用volatile关键词试图阻止过度优化：
1. 阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回。
2. 阻止编译器调整操作volatile变量的指令顺序。
但也无法阻止CPU动态调度换序。

要保证线程安全，阻止CPU换序是必需的。通常情况下是调用CPU提供的一条指令，这条指令常常被称为barrier。

一对一线程缺点有两个：
1. 由于许多操作系统限制了内核线程的数量，因此一对一线程会让用户的线程数量收到限制。
2. 许多操作系统内核线程调度时，上下文切换的开销大，导致用户线程的执行效率地下。

gcc的过程可以分解为4个步骤，分别是预处理（Preprocessing）、编译器（Compilation）、汇编（Assembly）和链接（Linking）。

预编译过程主要处理那些源代码文件中的以“#”开头的预编译指令：
+ 将所有的“#define”删除，并且展开所有的宏定义。
+ 处理所有条件预编译指令。
+ 处理“#include”预编译指令，将被包含的文件插入到盖预编译指令的位置。
+ 删除所有的注释。
+ 添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号。
+ 保留所有的#pragma编译器指令，因为编译器需要使用它们。

编译的过程一般可以分成6步：扫描、语法分析、语义分析、源代码分析、代码生成和目标代码优化。图4

符号（Symbol）用来表示一个地址。

C/C++模块之间通信有两种方式，一种是模块间的函数调用，另外一种是模块间的变量访问。所以可以归结为一种方式，那就是模块间符号的引用。

链接过程主要包括了地址和空间的分配（Address and Storage Allocation）、符号决议（Symbol Resolution）和重定位（Relocation）等这些步骤。

最常见的库就是运行库（Runtime Library，它是支持程序运行的基本函数集合。库其实是一组目标文件的包。

地址修正的过程也被叫做重定位，每个要被修正的地方叫一个重定位入口（Relocation Entry）。

目标文件从结构上讲，它是已经编译后的可执行文件，只是还没有经过链接的过程。其实它本身就是按照可执行文件格式存储的。

目标文件中的内容有编译后的机器指令代码、数据，还包括了链接时所需要的一些信息，比如符号表、调试信息、字符串等。将这些信息按不同的属性，以“节”（Section）的形式存储，有时候也叫“段”（Segment）。

程序源代码编译后的机器指令经常被放在代码段（Code Section）里，全局变量和局部静态变量经常放在数据段（Data Section）。

ELF文件开头是一个“文件头”，它描述了整个文件的文件属性，包括文件是否可执行、是静态链接还是动态链接及入口地址、目标硬件、目标操作系统等信息，文件头还包括一个段表（Section Table）。文件头后面就是各个段的内容。

数据和指令分段的好处，主要有如下几个方面：
+ 当进程被装载之后，数据和指令分别被映射到两个虚存区域，可以被分别设置权限。可以防止程序的指令被有意或无意地改写。
+ 现代CPU的缓存一般都被设计成数据缓存和指令缓存分离，所以程序的指令和数据被分开存放堆CPU的缓存命中率提高有好处。
+ 通过共享指令的概念，可以节省大量空间。

为了支持C++的复杂特性，人们发明了符号修饰（Name Decoration）或符号改编（Name Mangling）的机制。

函数签名（Function Signature）包含了一个函数的信息，包括函数签名、他的参数类型、它所在的类和名称空间及其他信息。

由于不同的编译器采用不同的名字修饰方法，必然会导致由不同编译器编译产生的目标文件无法正常相互链接。

针对强弱符号的概念，链接器就会按如下规则处理与选择被多次定义的全局符号：
+ 不允许强符号被多次定义。
+ 如果一个符号在某个目标文件中是强符号，在其他文件中都是弱符号，那么选择强符号。
+ 如果一个符号在所有目标文件中都是弱符号，那么选择其中占用空间最大的一个。

现代的链接器空间分配一般采用一种叫两步链接（Two-pass Linking）的方法。
+ 第一步 空间与地址分配。这一步中链接器将能够获得所有输入目标文件的段长度，并且将它们合并，计算出输出文件中各个段合并之后的长度与位置，并建立映射关系。
+ 第二部 符号解析与重定位。 使用上一步收集到的所有信息，读取输入文件中段的数据、重定位信息，而且进行符号解析与重定位、调整代码中的地址等。

C++的一些语言特性使之必须由编译器和链接器共同支持才能完成工作。最主要的有两个方面，一个是C++的重复代码消除，还有一个就是全局构造与析构。另外由于C++语言的各种特性，使得它背后的数据结构异常复杂，使得C++程序的二进制兼容性成了一个很大的问题。

函数级别链接（Functional-Level Linking）的作用就是让所有的函数都像前面模板函数一样，单独保存到一个段里面。当链接器需要用到某个函数时，它就将它合并到输出文件中，对于那些没有用的函数则将它们抛弃。这样的做法可以很大程度上减小文件输出的长度，减少空间浪费。

如果要使两个编译器编译出来的目标文件能够相互连接：
+ 采用相同的目标文件格式
+ 拥有同样的符号修饰标准
+ 变量的内存分布方式相同
+ 函数的调用方式相同 \
等等

我们把符号修饰标准、变量内存布局、函数调用方式等这些跟可执行代码二进制兼容性相关的内容称为ABI。

一个静态库可以简单地看成一组目标文件的集合。

链接器控制整个链接过程有如下三种方法：
+ 使用命令行来给链接器指定参数。
+ 将链接指令存放在目标文件里面。
+ 使用链接控制脚本。

COFF文件的文件头包括两部分，一个时描述文件总体结构和属性的映像头（Image Header），另外一个是描述该文件中包含的段属性的段表（Section Table）。

因为PE文件在装载时被直接映射到进程的虚拟空间中运行，它是进程的虚拟空间的映像。所以PE可执行文件很多时候被叫做映像文件。

覆盖装入（Overlay）和页映射（Paging）是两种很典型的动态装载方法。

程序执行最开始只需要做三件事情：
+ 创建一个独立的虚拟地址空间。
+ 读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系。
+ 将CPU的指令寄存器设置成可执行文件的入口地址，启动运行。

对于相同权限的段，把它们合并到一起当作一个段进行映射。

每个PE文件在装载时都会有一个装载目标地址（Target Address），这个地址就是所谓的基地址（Base Address）。由于PE文件被设计成可以装载到任何地址，所以这个基地址并不是固定的，每次装载时都可能会变化。

装载一个PE可执行文件：
1. 先读取文件的第一个页，这个页中，包含了DOS头、PE文件头和段表。
2. 检查进程地址空间中，目标地址是否可用。
3. 使用段表中提供的信息，将PE文件中所有的段一一映射到地址空间中相应的位置。
4. 如果装载地址不是目标地址，则进行Rebasing。
5. 装载所有PE文件所需要的DLL文件。
6. 对PE文件中的所有导入符号进行解析。
7. 根据PE头中指定的参数，建立初始化堆和栈。
8. 建立主线程并且启动进程。

静态链接的诸多缺点也逐步暴露出来，比如浪费内存和磁盘空间、模块更新困难等问题，使得人们不得不寻找一种更好的方式来组织程序的模块。

把链接这个过程推迟到了运行时再进行，这就是动态链接（Dynamic Linking）的基本思想。

动态链接器与普通共享对象一样，被映射到了进程的地址空间，在系统开始运行程序之前，首先会把控制权交给动态链接器，由它完成所有的动态链接工作以后再把控制权交给程序，然后开始执行。

共享对象的最终装载地址在编译时是不确定的，而是在装载时，装载器根据当前地址空间的空闲情况，动态分配一块足够大小的虚拟地址空间给相应的共享对象。

希望程序模块中共享的指令部分在装载时不需要因为装载地址的改变而改变，所以实现的基本想法就是把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。这种方案就是目前被称为地址无关代买（PIC，Position-independent Code）的技术。

ELF采用了一种叫做延迟绑定（Lazy Binding）的做法，基本的思想就是当函数第一次被用到时才进行绑定（符号查找、重定位等），如果没有用到则不进行绑定。

动态链接的步骤基本上分为三步：
1. 启动动态链接器本身。
2. 装载所有需要的共享对象。
3. 重定位和初始化。

动态链接器本身不可以依赖于其他任何共享对象；其次是动态链接器本身所需要的全局和静态变量的重定位工作由它本身完成。

当一个新的共享对象被装载进来的时候，它的符号表会被合并到全局符号表中，所以当所有的共享对象都被装载进来的时候，全局符号表里面将包含进程中所有的动态链接所需要的符号。

一个共享对象里面的全局符号被另一个共享对象的同名全局符号覆盖的现象又被称为共享对象全局符号介入（Global Symbol Interpose）。

当一个符号需要被加入全局符号表时，如果相同的符号名已经存在，则后加入的符号被忽略。

支持动态链接的系统往往都支持一种更加灵活的模块加载方式，叫做显式运行时链接（Explicit Run-time Linking），有时候也叫做运行时加载。也就是让程序自己在运行时控制加载指定的模块，并且可以在不需要该模块时将其卸载。

解决共享模块中符号名冲突的问题：
1. 装载序列（Load Ordering）
2. 依赖序列（Dependency Ordering）

共享库的更新可以被分为两类：
1. 兼容更新
2. 不兼容更新

导致C语言的共享库ABI改变的行为主要有如下4个：
+ 导出函数的行为发生改变。（？）
+ 导出函数被删除。
+ 导出数据的结构发生变化。
+ 导出函数的接口发生变化。

很多因素会导致ABI的不兼容，比如不同版本的编译器、操作系统和硬件平台，使得ABI兼容尤为困难。使得不同版本的编译器或系统库可能会导致结构体的成员对齐方式不一致，从而导致了ABI的变化。

对于C++来说，ABI问题就更为严重了。
+ 不要在接口类中使用虚函数，万不得已要使用虚函数时，不要随意删除、添加或在子类中添加新的实现函数，这样会导致类的虚函数表结构发生变化。
+ 不要改变类中任何成员变量的位置和类型。
+ 不要删除非内嵌的public或protected成员函数。
+ 不要将非内嵌的成员函数改变成内嵌成员函数。
+ 不要改变成员函数的访问权限。
+ 不要再接口中使用模板。
+ 不要改变接口的任何部分或干脆不要使用C++作为共享库接口。

COM的一些精神，用于指导我们使用C++编写动态链接库：
+ 所有的接口函数都应该是抽象的。所有的方法都应该是纯虚的。（或者inline的方法也可以）。
+ 所有的全局函数都应该使用extern “C"来防止名字修饰不兼容。并且导出函数都应该是__stdcall调用规范的。
+ 不要使用C++标准库STL。
+ 不要使用异常。
+ 不要使用虚析构函数。
+ 不要在DLL里面申请内存，而且在DLL外释放。
+ 不要再就口中使用重载方法（Overloaded Methods）。因为不同的编译器对于vtable安排可能不同。

栈保存了一个函数调用所需要的维护信息，这常常被称为堆栈帧（Stack Frame）或活动记录（Activate Record）。堆栈帧一般包括如下几个方面内容：
+ 函数的返回地址和参数。
+ 临时变量。
+ 保存的上下文。

一个i386下的函数总是这样调用的：
+ 把所有或一部分参数压入栈中，如果有其他参数没有入栈，那么使用某些特定的寄存器传递。
+ 报当前指令的下一条指令的地址压入栈中。
+ 跳转到函数体执行。

调用惯例的区别：
+ 函数参数的传递顺序和方式。
+ 栈的维护方式。
+ 名字修饰（Name-mangling）的策略。

如果返回值类型的尺寸太大，C语言在函数返回时会使用一个临时的栈上内存区域作为中转，结果返回值对象会被拷贝两次。

管理着堆空间分配的往往是程序的运行库。