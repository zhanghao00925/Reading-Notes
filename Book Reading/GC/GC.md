# 概述

GC基本上是高负载处理，需要花费一些时间，当编写游戏这样追求即时性的程序时，就必须尽量压低GC导致的最大暂停时间。对于音乐和动画这样类似编码应用的程序来说，更为重要的是，必须选择一个整体处理时间更短的算法。

GC把可以直接或间接从全局变量空间中引用的对象视为活动对象。

调用栈、寄存器以及全局变量空间都是根。

GC在一般情况下无法严谨地判断寄存器和调用栈中的值是指针还是非指针，为了判断根中的指针，我们需要下点功夫。

评价GC算法的性能时，我们采用以下四个标准。
+ 吞吐量
+ 最大暂停时间
+ 堆使用效率
+ 访问的局部性

# GC 标记-清除算法

在标记阶段，collector会为堆里所有的活动对象打上标记。标记所花费的时间是与“活动对象的总数”成正比的。

在清除阶段，程序会遍历所有堆，进行垃圾回收。也就是说，所花费的时间与堆大小成正比。堆越大，清除阶段所花费的时间就会越长。

“连接连续分块”的操作就叫作合并（coalescing），合并操作是在清除阶段进行的。

## 优点

### 实现简单

引用计数法中就很难切实管理计数器的增减，实现也很困难。如果算法实现简单，那么它与其他算法的组合也就相应地简单。

### 与保守式GC算法兼容

保守式GC算法中，对象是不能被移动的。而GC标记-清除算法因为不会移动对象，所以非常适合搭配保守式GC算法。

## 缺点

### 碎片化

在GC标记-清除算法的使用过程中会逐渐产生被细化的分块。如果发生碎片化，就会增加mutator的执行负担。把具有引用关系的对象安排在堆中较远的位置，就会增加访问所需的时间。

### 分配速度

每次分配都必须遍历空闲链表。后面叙述的多个空闲链表（multiple free-list）和BiBOP法都是为了能在GC标记-清除算法中高速进行分配而想出的方法。

### 与写时复制技术不兼容

写时复制技术只是装作已经复制了内存空间，实际上是将内存空间共享了。即使没重写对象，GC也会设置所有活动对象的标志位，这样就会频繁发生本不应该发生的复制，压迫到内存空间。

## 多个空闲链表

创建只连接大分块的空闲链表和只连接小分块的空闲链表。

## BiBOP法

BiBOP是Big Bag Of Pages的缩写。将大小相近的对象整理成固定大小的块进行管理的做法。把堆分割成固定大小的块，让每个块之只能配置同样大小的对象。

## 位图标记

在标记的时候，不在对象的头里置位，而是在这个表格中的特定场所置位。重要的是，位图表格中位的位置要和堆里的各个对象切实对应。

### 与写时复制技术兼容

以上问题只发生在写时复制的运行环境（linux等）中，以及频繁执行fork()函数的应用程序。

### 清除操作更高效

把所有对象的标志位集合到一起，所以可以快速消去标志位。

### 要注意的地方

在堆为多个的情况下，一般会为每个堆都准备一个位图表格。

## 延迟清除

延迟清除法（Lazy Sweep）是缩减因清除操作而导致的mutator最大暂停时间的方法。

延迟清除法不是一下遍历整个堆，他只是在分配时执行必要的遍历，所以可以压缩因清除操作而导致的mutator的暂停时间。

延迟清除的效果时不均衡的。

在清除垃圾较多的部分时马上获得分块，然而一旦程序开始清除活动对象周围，就怎么也无法获得分块了。

# 引用计数法

在引用计数法中，除了连接到空闲链表的对象，其他所有对象都是活动对象。计数器的值为0的对象变成了“垃圾”。

引用计数法中会监督在更新指针的时候是否有产生垃圾，从而在产生垃圾时将其立刻回收。可以说将内存管理和mutator同时运行正是引用计数法的一大特征。

## 优点

### 可即刻回收垃圾

内存空间不会被垃圾占领。

### 最大暂停时间短

### 没有必要沿指针查找

在分布式环境中，如果要沿着各个计算节点之间的指针进行查找，成本就会增加，因此需要极力控制沿指针查找的次数。

## 缺点

### 计数器值的增减处理繁重

### 计数器需要占用很多位

### 实现繁琐复杂

### 循环引用无法回收

## 延迟引用计数方法

在延迟引用计数法中使用ZCT（Zero Count Table）。

### 优点

减轻了因根频繁发生变化而导致的计数器增减所带来的额外负担。

### 缺点

失去了引用计数法的一大优点，可即刻回收垃圾。

## Sticky应用计数法

针对计数器溢出，需要暂停堆计数器的管理

+ 有很多研究表明，很多对象一生成马上就死了，也就是不增减计数器的值，就把它那么放着也不会有什么大问题。
+ 使用GC-标记清除算法进行管理，还有一个优点，那就是还能回收循环的垃圾。

## 1位引用计数法

因为指针通常默认为4字节对齐，所以没法利用低2位，利用这个性质。

### 优点

不容易出现高速缓存缺失。节省了内存消耗量。

### 缺点

没法保证mutator能一直顺利运行

## 部分标记-清除算法

像这样只对一部分对象群使用GC标记-清除算法的方法，叫做“部分标记-清除算法”（Partial Mark&Sweep）。

（Detail to be added）

# GC复制算法

只把某个空间里的活动对象复制到其他空间，把原空间的所有对象都回收掉。

要实现这个方法有2个条件。首先，每个对象都至少要有2个域，分别用作COPIED标签和forwarding指针。

## 优点

### 优秀的吞吐量

之搜索并复制活动对象，所以跟一般的GC标记-清除算法相比，能在较短的时间内完成GC。

尤其是堆越大，差距越明显。毕竟它消耗的时间是与活动对象的数量成比例的。

### 可实现高速分配

比起GC标记-清除算法和应用计数算法等使用空闲链表的分配，GC复制算法明显快得多。

### 不会发生碎片化

像这样把对象重新集中，放在堆的一端的行为就叫做压缩。

### 与缓存兼容

在GC复制算法中有引用关系的对象会被安排在堆里离彼此比较近的位置。mutator的执行速度极快。

## 缺点

### 堆使用效率地下

只有一般的堆能被使用。

### 不兼容保守式GC算法

### 递归调用函数

复制时要递归复制它的子对象。每次递归调用时都会消耗栈，所以还有栈溢出的可能。

## Cheney的GC复制算法

不是递归地，而是迭代地进行复制。

### 优点

抑制调用函数的额外负担和栈的消耗。

### 缺点

没法说Cheney的GC复制算法兼容缓存，只能说它比GC标记-清除算法和引用计数算法要好一些而已。

## 近似深度优先搜索方法

（Detail to be added）

## 多空间复制算法

### 优点

空间利用率高

### 缺点

执行GC复制算法的只有N等分中的两块空间，对于剩下的(N-2)块空间执行的是GC标记-清除算法。出现了GC标记-清除算法固有的问题，分配耗费时间，分块碎片化。

# GC标记-压缩算法

Lisp2算法

压缩阶段由以下3个步骤构成。
+ 设定forward指针
+ 更新指针
+ 移动对象

## 优点

### 可有效利用堆

## 缺点

## 压缩花费计算成本

必须对整个堆进行3次搜索。执行该算法所花费的时间是和堆大小成正比的。

## Two-Finger算法

有着很大的制约条件，那就是“必须将所有对象整理成大小一致”。

### 优点

因为算法能把forwarding指针设置在移动前的对象的域里，所以不需要额外的内存空间用于forwarding指针。

搜索次数只有2此，比Lisp2算法少一次。

### 缺点

不考虑应用关系，无法期待这个算法能沾缓存的光。

所有对象的大小必须一致。利用BiBOP算法能克服这个问题。

## 表格算法

表格算法通过以下2个步骤来执行压缩

+ 移动对象(群)以及构筑间隙表格（break table）
+ 更新指针

### 优点

没有必要为压缩准备出多余的空间。

### 缺点

维持间隙表格都需要付出很高的代价。

更新指针时也不能忽略搜索表格所带来的消耗。

## ImmixGC算法

它将GC标记-清除算法和压缩组合在了一起。

### 优点

ImmixGC最大的特征是将对象分成块和线两个阶段进行管理。

把块分成了更小的线。这样一来，就能更精确地管理块里的对象，抑制堆的消耗量。

因为将碎片化严重的块拿来当备用From块，所以可以有效地解决碎片化问题。

### 缺点

对象不是按顺序保存的，所以不要期待ImmixGC能沾缓存的光。曾经做过保守的标记，那些没有活动对象的线有可能无法被回收。无法有效地使用堆。

# 保守式GC

保守式GC会检查不明确的根，以“某种程度”的精度来识别指针。
+ 是不是被正确对齐的值？
+ 是不是指着堆内？
+ 是不是指着对象的开头？

在运行GC时采取的是一种保守的态度，即“把可疑的东西看作指针，稳妥处理”，所以我们称这种方法为“保守式GC”。

以C语言为例，所有的域里面都包含了类型信息，除了union。

## 优点

### 语言处理程序不依赖于GC

## 缺点

### 识别指针和非指针需要付出成本

### 错误识别指针会压迫堆

### 能够使用的GC算法有限

## 准确式GC

它是能准确识别指针和非指针的GC。

需要“语言处理程序的支援”
+ 打标签
+ 不把寄存器和栈等当作根

### 优点

堆里只会留下活动对象。

### 缺点

要创建正确的根就必须付出一定的代价。这就关系到语言处理程序的执行速度了。

## 间接引用

解决保守式GC的“不能使用GC复制算法等移动对象的算法”的方法之一就是“间接引用”。

解决这个问题的办法就是经由句柄（handle）来间接地处理对象。

### 优点

可以得到GC复制算法所带来的好处。

### 缺点

因为所有对象都（经由句柄）间接引用，所以会拉低访问对象内部数据的速度。

## MostlyCopyingGC

简单地来说就是“把那些不明确的根指向的对象以外的对象都复制的GC算法”。此外，还有如下这些前提条件：
+ 根是不明确的根
+ 没有不明确的数据结构（能够明确判断对象里的域是指针还是非指针）
+ 对象大小随意
+ CPU是32为（非必要）

MostlyCopyingGC有个特点，就是不会回收包含有从根指向对象的页里的垃圾对象，而且也不会回收这个垃圾对象所引用的对象群。

### 优点和缺点

首先就是能在保守式GC里使用GC复制算法。缺点是不会回收包含有从根指向对象的页里的垃圾对象。

## 黑名单

改善上面算法的问题的办法就是黑名单。

黑名单里记录的是“不明确的根内的非指针，其指向的是有可能被分配对象的地址”。将对象分配到需要注意的地址时，所分配的对象有着如下限值条件：
+ 小对象
+ 没有子对象的对象

### 优点和缺点

GC对象少于通常的保守式GC里的对象，GC的执行速度也大大提高了。不过，在分配对象时需要花功夫来检查黑名单。

# 分代垃圾回收

因为老年代对象很难成为垃圾，所以我们对老年代对象减少执行GC的频率。分代垃圾回收不能单独用来执行GC。

## Ungar的分代垃圾回收

总共需要4个空间，分别是生成空间、2个相等的幸存空间以及老年代空间。

生成空间和From幸存空间这两个空间里的活动对象都会被复制到To幸存空间去。这就是新生代GC。只有从一定次数的新生代GC中存活下来的对象才会得到晋升，也就是会被复制到老年代空间去。还需要将从老年代空间的引用当作根来处理。

老年代GC用到了GC标记-清除算法。

### 记录集

记录集被用于高效地寻找从老年代对象到新生代对象的引用。

### 写入屏障

为了将老年代对象记录到记录集里。在mutator更新对象间的指针的操作中，写入屏障是不可或缺的。

## 优点

### 吞吐量得到改善

实验表明，分代垃圾回收花费的时间是GC复制算法的四分之一。

## 缺点

### 在部分程序中会起到反作用

对象会活得很久的程序也有很多，就会产生两个问题：
+ 新生代GC所花费的时间增多
+ 老年代GC频繁运行

写入屏障导致的额外负担降低了吞吐量。

## 记录各代之间的引用的方法

### 卡片标记

### 页面标记

## 多代垃圾回收

分代越多，每代的空间也就相应地变小了，这样一来各代之间的引用就变多了，各代中垃圾回收花费的时间也就越来越长了。

## 列车垃圾回收

（Detail to be added）

# 增量式垃圾回收

有时停止型垃圾回收是很要命的。因此人们想出了增量式垃圾回收这种方法。

## 优点和缺点

### 缩短最大暂停时间

### 降低了吞吐量

## Steele算法

（Detail to be added）

## 汤浅的算法

（Detail to be added）

# RC Immix算法

（Detail to be added）
